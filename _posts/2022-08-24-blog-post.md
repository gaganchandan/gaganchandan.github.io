---
title: "A Deep Dive Into *Hello, World!*"
date: 2022-08-24
permalink: /posts/2022/08/Hello World/
tags:
  - C
  - Assembly
---

<h4 color=silver><i>A peek behind the curtains of everyone's favourite program!</i></h6>
<br/>

*Hello, World!*. Perhaps the simplest of computer programs. Every single person starting out with programming starts out with a *Hello, World!* program. When learning a new programming language, *Hello, World!* programs are written by experienced developers as well. As you can see [here](https://github.com/leachim6/hello-world), *Hello, World!* programs have been written in 937 different programming languages (at the time of writing) and counting!

Let's take a look at a *Hello, World!* program written in C.

```
$ cat hello_world.c
#include <stdio.h>

int main()
{
    puts("Hello, World!");
    return 0;
}
```

Seems simple enough, right?

But actually, there is a lot that goes on behind the scenes before we see the output of on our screen. In this post, we will pull away the curtains and see exactly how this program works. We will go all the way down to the assembly level to see how the program is implemented. We will also journey through header files and take a closer a look at how one of the most common functions in C is implemented.Finally, we will learn a little bit about how our program interacts with hardware via the *kernel*.  We will be dissecting a *Hello, World!* program compiled with `gcc 11.2.0` and executed on a Linux system(`Ubuntu 22.04.1 LTS` with kernel version `5.15.0-46-generic`). Feel free to try everything we do today on your own Linux system. The results will be similar on other distributions and with different kernel versions as well. 

## Compilation

The first step in the process is compilation. The specifics of the C compilation process are quite compilcated and are beyond the scope of this post. However, I will provide an overview of how all the different parts of a C program are put together.

Compiling a C program usually consists of four different phases:

### 1. Preprocessing

This is the phase of compilation that deals with *preprocessor directives* such as `#include` and `#define` and transforms the program before the actual compilation. The preprocessor provides multiple facilities including the inclusion of header files and the expansion of macros. In our program, it 
copies the source of the header file in its entirety into our program. Preprocessor output for a program can generated by `gcc` as follows:

```
$ gcc -E -P hello_world.c > preprocessor.txt
```
Here we have redirected the preprocessor output to a file named *preprocessor.txt*. Viewing the contents of the file, we can see that the entire `stdio` header file has now been included in our source file.

Let us view the beginning and end of the output:
```
$ head -n 10 preprocessor.txt
typedef long unsigned int size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;

$ tail -n 10 preprocessor.txt
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);

int main()
{
    puts("Hello, World!");
    return 0;
}

```
For the sake of brevity, the entire output has not been shown. As you can see, the main function remains unchanged, but the `#include` directive has disappeared and in its place is the entire source of the `stdio` header file.

### 2. Compilation

The second phase in C compilation is called ... *compilation*. (It's a bit odd, but please bear with it.) In this phase, the preprocessed code is converted into [assembly language.](https://en.wikipedia.org/wiki/Assembly_language) The output of this process is fairly readable and symbolic information (such as variable and function names) is preserved. The output of the compilation phase can be generated by `gcc` with the following command:
```
$ gcc -S hello_world.c -masm=intel
```
Here the `-masm=intel` flag produces assembly output in Intel syntax as opposed to the default AT&T syntax. (Read [this](http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html) to know the prominent differences between the two syntaxes.) The above command should have generated an assembler source file with a `.s` extension.
```
$ file hello_world.s
hello_world.s: assembler source, ASCII text
```
Let us view the contents of this file.
```
$ cat hello_world.s
	.file	"hello_world.c"
	.intel_syntax noprefix
	.text
	.section	.rodata
.LC0:
	.string	"Hello, World!"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	push	rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	mov	rbp, rsp
	.cfi_def_cfa_register 6
	lea	rax, .LC0[rip]
	mov	rdi, rax
	call	puts@PLT
	mov	eax, 0
	pop	rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 11.2.0-19ubuntu1) 11.2.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:
```
We can clearly see a `main` function in the assembler source. We can also see the string which is to be printed, specifically the string `"Hello, World!"`. We will look at this assembly in detail later.

### 3. Assembly

This is the third phase of the compilation process. In the phase, the assembler source generated in the previous phase is *assembled* to produce machine code. This phase generates something known as an object file which contains machine code, also known as object code. These files have a `.o` extension. Object files can be generated by `gcc` with the following command:
```
gcc -c hello_world.c
```

Next, we run the file command on the object file generated:
```
$ file hello_world.o
hello_world.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
```

As we can see, the file is a 64-bit [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) (Executable and Linkable Format) file. Although object files contain machine instructions that the processor recognises, these files are not executable as of yet. The file is *relocatable*, meaning it does not need to be placed at a particular address in memory.

### 4. Linking
The final phase is known as linking. This is the phase that produces our final executable. To put it roughly, in this phase, the *linker* amalgamates parts of object files together to piece together an executable file. Run the following command to produce the final executable from source:
```
gcc hello_world.c -o hello_world
```
This implements all four phases of compilation and produces our *Hello, World!* executable. 


Let us now take a look at this executable.
```
$ file hello_world
hello_world: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2bff0e0874d11914d4cba084527f3cb9257e0036, for GNU/Linux 3.2.0, not stripped
```
Clearly, an executable 64-bit ELF file has been generated. Such files are also called *binaries*. When this file is executed, the operating system sets up a process for it which includes a *virtual address space* (read more about virtual memory [here](https://en.wikipedia.org/wiki/Virtual_memory)). The *interpreter* (in this case, `/lib64/ld-linux-x86-64.so.2`) is a user space program that knows to *load* the binary. Loading is a very complicated process and is unfortunately beyond the scope of this article. For more information on loading, look [here](https://lwn.net/Articles/631631/).

Finally, let us run our program.
```
$ ./hello_world
Hello, World!
```
And there we have it! Our *Hello, World!* program in all its glory!

With this, we finish our brief discussion of the compilation process.

## *Hello, World!*  in Assembly

Next, let us take a quick look at the assembler source. If you are not familiar with x86/x86-64 assembly, take a glance at the following resources before you proceed: [1](https://shellsharks.com/intel-assembly-primer) [2](http://www.securitytube.net/groups?operation=view&groupId=5) [3](https://www.youtube.com/playlist?list=PL038BE01D3BAEFDB0)


