---
title: "A Deep Dive Into *Hello, World!* - Part One"
subtitle: "A peek behind the curtains of everyone's favourite program!"
date: 2022-08-24
permalink: /posts/HelloWorld1/
tags:
  - C
  - Assembly
---

*Hello, World!*. Perhaps the simplest of computer programs. Every single person starting out with programming starts out with a *Hello, World!* program. When learning a new programming language, *Hello, World!* programs are written by experienced developers as well. As you can see [here](https://github.com/leachim6/hello-world), *Hello, World!* programs have been written in 937 different programming languages (at the time of writing) and counting!

Let's take a look at a *Hello, World!* program written in C.

```c
$ cat hello_world.c
#include <stdio.h>

int main()
{
    puts("Hello, World!");
    return 0;
}
```

Seems simple enough, right?

But actually, there is a lot that goes on behind the scenes before we see the output of this program on our screen. In this two post series, we will pull away the curtains and see exactly how this program works. We will go all the way down to the assembly level to see how the program is implemented. We will also journey through header files and take a closer a look at how one of the most common functions in C is implemented.Finally, we will learn a little bit about how our program interacts with hardware via the *kernel*.  We will be dissecting a *Hello, World!* program compiled with `gcc 11.2.0` and executed on a Linux system(`Ubuntu 22.04.1 LTS` with kernel version `5.15.0-46-generic`). Feel free to try everything we do today on your own Linux system. The results will be similar on other distributions and with different kernel versions as well. 

## Compilation

The first step in the process is compilation. The specifics of the C compilation process are quite compilcated and are beyond the scope of this post. However, I will provide an overview of how all the different parts of a C program are put together.

Compiling a C program usually consists of four different phases:

### 1. Preprocessing

This is the phase of compilation that deals with *preprocessor directives* such as `#include` and `#define` and transforms the program before the actual compilation. The preprocessor provides multiple facilities including the inclusion of header files and the expansion of macros. In our program, it 
copies the source of the header file in its entirety into our program. Preprocessor output for a program can generated by `gcc` as follows:

```
$ gcc -E -P hello_world.c > preprocessor.txt
```
Here we have redirected the preprocessor output to a file named *preprocessor.txt*. Viewing the contents of the file, we can see that the entire `stdio` header file has now been included in our source file.

Let us view the beginning and end of the output:
```c
$ head -n 10 preprocessor.txt
typedef long unsigned int size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;

$ tail -n 10 preprocessor.txt
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);

int main()
{
    puts("Hello, World!");
    return 0;
}

```
For the sake of brevity, the entire output has not been shown. As you can see, the main function remains unchanged, but the `#include` directive has disappeared and in its place is the entire source of the `stdio` header file.

### 2. Compilation

The second phase in C compilation is called ... *compilation*. (It's a bit odd, but please bear with it.) In this phase, the preprocessed code is converted into [assembly language.](https://en.wikipedia.org/wiki/Assembly_language) The output of this process is fairly readable and symbolic information (such as variable and function names) is preserved. The output of the compilation phase can be generated by `gcc` with the following command:
```
$ gcc -S hello_world.c -masm=intel
```
Here the `-masm=intel` flag produces assembly output in Intel syntax as opposed to the default AT&T syntax. (Read [this](http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html) to know the prominent differences between the two syntaxes.) The above command should have generated an assembly source file with a `.s` extension.
```
$ file hello_world.s
hello_world.s: assembler source, ASCII text
```
Let us view the contents of this file.
```gas
$ cat hello_world.s
	.file	"hello_world.c"
	.intel_syntax noprefix
	.text
	.section	.rodata
.LC0:
	.string	"Hello, World!"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	push	rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	mov	rbp, rsp
	.cfi_def_cfa_register 6
	lea	rax, .LC0[rip]
	mov	rdi, rax
	call	puts@PLT
	mov	eax, 0
	pop	rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 11.2.0-19ubuntu1) 11.2.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:
```
We can clearly see a `main` function in the assembly source. We can also see the string which is to be printed, specifically the string `"Hello, World!"`. We will look at this assembly in detail later.

### 3. Assembly

This is the third phase of the compilation process. In the phase, the assembly source generated in the previous phase is *assembled* to produce machine code. This phase generates something known as an object file which contains machine code, also known as object code. These files have a `.o` extension. Object files can be generated by `gcc` with the following command:
```
$ gcc -c hello_world.c
```

Next, we run the file command on the object file generated:
```
$ file hello_world.o
hello_world.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
```

As we can see, the file is a 64-bit [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) (Executable and Linkable Format) file. Although object files contain machine instructions that the processor recognises, these files are not executable as of yet. The file is *relocatable*, meaning it need not be placed at a particular address in memory.

### 4. Linking
The final phase is known as linking. This is the phase that produces our final executable. To put it roughly, in this phase, the *linker* amalgamates parts of object files together to piece together an executable file. Run the following command to produce the final executable from source:
```
$ gcc hello_world.c -o hello_world
```
This implements all four phases of compilation and produces our *Hello, World!* executable. 


Let us now take a look at this executable.
```
$ file hello_world
hello_world: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2bff0e0874d11914d4cba084527f3cb9257e0036, for GNU/Linux 3.2.0, not stripped
```
Clearly, an executable 64-bit ELF file has been generated. Such files are also called *binaries*. When this file is executed, the operating system sets up a process for it which includes a *virtual address space* (read more about virtual memory [here](https://en.wikipedia.org/wiki/Virtual_memory)). The *interpreter* (in this case, `/lib64/ld-linux-x86-64.so.2`) is a user space program that knows to *load* the binary. Loading is a very complicated process and is unfortunately beyond the scope of this article. For more information on loading, look [here](https://lwn.net/Articles/631631/).

Finally, let us run our program.
```
$ ./hello_world
Hello, World!
```
And there we have it! Our *Hello, World!* program in all its glory!

With this, we finish our brief discussion of the compilation process.

## *Hello, World!*  in Assembly

Next, let us take a quick look at the assembly source. If you are not familiar with x86/x86-64 assembly, take a glance at the following resources before you proceed:  [1](https://www.youtube.com/playlist?list=PL038BE01D3BAEFDB0) [2](http://www.securitytube.net/groups?operation=view&groupId=5) [3](https://shellsharks.com/intel-assembly-primer)

The assembly source file we genereated earlier (`hello_world.s`) contains a lot of 'noise' such as [CFI directives](https://sourceware.org/binutils/docs-2.24/as/CFI-directives.html#CFI-directives) which are not very pertinent to our discussion. To generate an assembly source file without these directives, use the following command:

```
$ gcc -S -fno-asynchronous-unwind-tables hello_world.c -masm=intel
```

Our assembly source now looks like this:

```asm
.file	"hello_world.c"
	.intel_syntax noprefix
	.text
	.section	.rodata
.LC0:
	.string	"Hello, World!"
	.text
	.globl	main
	.type	main, @function
main:
	endbr64
	push	rbp
	mov	rbp, rsp
	lea	rax, .LC0[rip]
	mov	rdi, rax
	call	puts@PLT
	mov	eax, 0
	pop	rbp
	ret
	.size	main, .-main
	.ident	"GCC: (Ubuntu 11.2.0-19ubuntu1) 11.2.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:
```

Looking at the code under the  `main` label, we can clearly see that it is now much more readable compared to the assembly we generated previously. There are other ways to see the assembly code behind a program. Compiled binaries can be disassembled by tools like `gdb` and `objdump` which are available on most, if not all, Linux distributions. Open up the binary in `gdb` with the following command:

```
$ gdb hello_world
```

You can view the disassembly in Intel syntax with the following commands:

```
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
   0x0000000000001149 <+0>:	endbr64 
   0x000000000000114d <+4>:	push   rbp
   0x000000000000114e <+5>:	mov    rbp,rsp
   0x0000000000001151 <+8>:	lea    rax,[rip+0xeac]        # 0x2004
   0x0000000000001158 <+15>:	mov    rdi,rax
   0x000000000000115b <+18>:	call   0x1050 <puts@plt>
   0x0000000000001160 <+23>:	mov    eax,0x0
   0x0000000000001165 <+28>:	pop    rbp
   0x0000000000001166 <+29>:	ret    
End of assembler dump.
```
With `objdump`, the procedure is as follows:

```
$ objdump -d -M intel hello_world > objdump.txt
$ cat objdump.txt
...
0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   rbp
    114e:	48 89 e5             	mov    rbp,rsp
    1151:	48 8d 05 ac 0e 00 00 	lea    rax,[rip+0xeac]        # 2004 <_IO_stdin_used+0x4>
    1158:	48 89 c7             	mov    rdi,rax
    115b:	e8 f0 fe ff ff       	call   1050 <puts@plt>
    1160:	b8 00 00 00 00       	mov    eax,0x0
    1165:	5d                   	pop    rbp
    1166:	c3                   	ret    

...
```

The `objdump` output above has been truncated to show only the disassembly of the `main` label.

Perhaps the simplest way to see disassembly, however,  is by using [Compiler Explorer](https://godbolt.org/). In this website, you can type in your C code and you will be shown the equivalent assembly produced by a compiler of your choice. It uses Intel syntax by default. Moreover, the assembly generated by this website is very easy to read as well. 

Let us type in our *Hello, World!* into the Compiler Explorer and examine the assembly output.

```
.LC0:
        .string "Hello, World!"
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        mov     eax, 0
        pop     rbp
        ret
```

In our `main` function, the first two instructions are:
```
push    rbp
mov     rbp, rsp
```

These two instructions are seen at the beginning of every function. Each function has its own *stack frame*, whcih is a frame of data pushed onto the stack containing all information pertaining to the called function such as arguments and local variables. The first instruction stores the *stack base pointer* (which is stored in `rbp` and holds the stack address of the base of the current function's stack frame) of the function which called our `main` function on the stack. The second instruction sets the base pointer of the `main` functions's stack frame to the current stack pointer. See more about function call stacks [here](https://en.wikipedia.org/wiki/Call_stack). 

In the third instruction of the assembly from Compiler Explorer, the string to be printed, "Hello, World!", is moved into the `rdi` register. In the assembly generated by `gcc`, `objdump` and `gdb`, this is achieved with the third and fourth instructions. The reason behind storing our string in `rdi` is the calling convention in x86-64 assembly. The first argument to a function is stored in `rdi`, the second argument in `rsi`, the third in `rdx`, the fourth in `rcx`, the fifth in `r9` and the sixth in `r8`. If there are more arguments, they are pushed onto the stack. `puts` only takes a single argument, which is a constant character pointer (`const char*`) and so, we don't need to have any specific values in any of the other argument registers.

After moving the correct value into `rdi`, the `puts` function is called. Functions in ELF binaries are called using the [Procedure Linkage Table](https://www.intel.com/content/www/us/en/docs/programmable/683836/current/procedure-linkage-table.html) and the [Global Offset Table](https://en.wikipedia.org/wiki/Global_Offset_Table). Unfortunately, this is a quite expansive topic and warrants a post or two of its own and hence, it won't be covered in this series. You can read more about PLT and GOT [here](https://www.airs.com/blog/archives/41) and [here](https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html). 

Penultimately, `0` is moved into the `eax` register. This is essential what the `return 0;` at the end of our C code does. `rax`, by convention, is the return register. The return value is the exit code of our program. If the return value of a program is `0`, it suggests that the program execution was successful. You will notice that `mov eax, 0` is used over `mov rax, 0`. This is because, while they both achieve the same thing, `mov eax, 0` (` b8 00 00 00 00`) uses fewer bytes compared to `mov rax, 0` (`48 c7 c0 00 00 00 00`).

Finally, the `ret` instruction is executed. This instruction is used to transfer control to the return address stored on the stack by a `call` instruction. When this instruction is executed, execution flow will resume at the instruction following the `call` instruction which called our `main` function. In ELF binaries, the `_start` function is where execution begins and this function is what calls our `main` function. For an in-depth look at how we get to `main`, read [this](http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html).

With this, we reach the end of the first post in our series. We took a brief look at C compilation and saw what a *Hello, World!* program looks like in assembly. In our next post, we will look at the program from a slightly higher level and see how the `puts` function is implemented in the C standard library. Then, we will explore Linux kernel 'syscalls' and how userspace programs such as ours interact with the kernel which then interacts with the hardware.

Stay tuned!!!
<br/>
<br/>
<br/>

If you have any suggestions, corrections or simply want to say hi, feel free to hit me up on [Twitter](https://twitter.com/gagan_chandan_) or on Discord at [GaganChandan#1296]().
